<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn how to implement secure user authentication in a Node.js backend and a React frontend using JWT and cookies">
    <title>Handling User Authentication in Node.js and React Using JWT and Cookies</title>
    <style>
        :root {
            --primary-color: #60a5fa;
            --secondary-color: #3b82f6;
            --accent-color: #38bdf8;
            --text-color: #e2e8f0;
            --light-text: #94a3b8;
            --bg-color: #1e293b;
            --card-bg: #0f172a;
            --code-bg: #1e293b;
            --border-color: #334155;
            --success-color: #4ade80;
            --tip-bg: #172554;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: #0f172a;
            padding:50px 0 ;
            margin: 0;
        }

        .blog-container {
            max-width: 850px;
            margin: 0 auto;
            background-color: var(--card-bg);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            overflow: hidden;
        }

        .blog-header {
            background: linear-gradient(135deg, #1e40af, #0d2770);
            color: white;
            padding: 2.5rem 2rem;
            text-align: center;
        }

        .blog-header h1 {
            font-size: 2.2rem;
            font-weight: 800;
            margin-bottom: 1rem;
            line-height: 1.3;
            color: #ffffff;
        }

        .blog-meta {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 1rem;
        }

        .blog-post {
            padding: 2rem;
        }

        section {
            margin-bottom: 3rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        section:last-child {
            border-bottom: none;
        }

        h2 {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--primary-color);
            margin: 1.5rem 0 1rem 0;
            padding-bottom: 0.5rem;
            position: relative;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 60px;
            height: 3px;
            background-color: var(--accent-color);
            border-radius: 3px;
        }

        h3 {
            font-size: 1.35rem;
            font-weight: 600;
            margin: 1.5rem 0 1rem 0;
            color: var(--secondary-color);
        }

        p {
            margin-bottom: 1.2rem;
            font-size: 1.05rem;
            color: var(--text-color);
        }

        ul, ol {
            margin: 1rem 0 1.5rem 1.5rem;
            color: var(--text-color);
        }

        li {
            margin-bottom: 0.5rem;
        }

        strong {
            font-weight: 600;
            color: var(--accent-color);
        }

        pre {
            background-color: var(--bg-color);
            border-radius: 6px;
            padding: 1rem;
            margin: 1.2rem 0;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        code {
            font-family: 'Fira Code', 'Consolas', 'Monaco', 'Andale Mono', monospace;
            font-size: 0.9rem;
            color: #a5f3fc;
        }

        .section-tip {
            background-color: var(--tip-bg);
            border-left: 4px solid var(--accent-color);
            padding: 1rem;
            margin:1.5rem 0;
            border-radius: 0 6px 6px 0;
        }

        .footer {
            text-align: center;
            padding: 2rem;
            background-color: #111827;
            color: var(--light-text);
            font-size: 0.9rem;
            border-top: 1px solid var(--border-color);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .blog-container {
                max-width: 100%;
                border-radius: 0;
                box-shadow: none;
            }
            
            .blog-header {
                padding: 2rem 1rem;
            }
            
            .blog-header h1 {
                font-size: 1.8rem;
            }
            
            .blog-post {
                padding: 1.5rem;
            }
            
            h2 {
                font-size: 1.5rem;
            }
            
            h3 {
                font-size: 1.25rem;
            }
        }
    </style>
</head>
<body>
    <div class="blog-container">
        <header class="blog-header">
            <h1>Handling User Authentication in Node.js and React Using JWT and Cookies</h1>
            <div class="blog-meta">Published on <time datetime="2023-10-18">October 18, 2023</time> • 18 min read</div>
        </header>
        
        <article class="blog-post">
            <section id="introduction">
                <h2>Introduction</h2>
                <p>User authentication is a critical component of modern web applications, forming the foundation of security and personalized user experiences. A robust authentication system not only protects sensitive user data but also enables features like personalization, access control, and secure transactions.</p>
                
                <p>In this comprehensive guide, we'll explore how to implement a secure and scalable authentication system using:</p>
                
                <ul>
                    <li><strong>JSON Web Tokens (JWT)</strong>: A compact, self-contained method for securely transmitting information between parties as a JSON object.</li>
                    <li><strong>HTTP-only Cookies</strong>: A secure way to store tokens that protects against common XSS attacks.</li>
                    <li><strong>Node.js and Express</strong>: For building a robust backend authentication API.</li>
                    <li><strong>React</strong>: For creating responsive and secure frontend authentication components.</li>
                </ul>
                
                <p>This authentication architecture strikes an optimal balance between security and user experience—protecting user credentials while maintaining smooth, stateless authentication flows across your application.</p>
            </section>
            
            <section id="prerequisites">
                <h2>Prerequisites</h2>
                <p>Before diving into implementation, ensure you have the following:</p>
                
                <ul>
                    <li>Node.js (v14 or later) and npm installed on your development machine</li>
                    <li>Basic understanding of JavaScript, React, and Express.js</li>
                    <li>Knowledge of HTTP protocols, REST APIs, and state management concepts</li>
                    <li>A code editor (VS Code recommended)</li>
                    <li>Postman or a similar tool for testing API endpoints</li>
                </ul>
                
                <p>This tutorial assumes you're starting with a basic Express.js server and React application. If you need to set these up, you can use the following commands:</p>
                
                <pre><code># Set up backend
mkdir auth-app && cd auth-app
mkdir backend && cd backend
npm init -y
npm install express cors jsonwebtoken bcrypt cookie-parser dotenv mongoose

# Set up frontend (in a separate terminal)
cd auth-app
npx create-react-app frontend
cd frontend
npm install axios react-router-dom</code></pre>
                
                <div class="section-tip">
                    <strong>Pro Tip:</strong> Consider using TypeScript for both frontend and backend to catch type-related errors early in development.
                </div>
            </section>
            
            <section id="step1">
                <h2>Step 1: Setting Up the Backend (Node.js + Express.js)</h2>
                
                <p>Let's start by creating a secure authentication server with Express.js that will handle user registration, login, and protected routes.</p>
                
                <h3>Project Structure</h3>
                
                <pre><code>backend/
├── config/
│   └── db.js
├── controllers/
│   └── authController.js
├── middleware/
│   └── authMiddleware.js
├── models/
│   └── User.js
├── routes/
│   └── authRoutes.js
├── .env
└── server.js</code></pre>
                
                <h3>Setting Up the Server</h3>
                
                <p>First, let's create our server.js file:</p>
                
                <pre><code>// server.js
require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cookieParser = require('cookie-parser');
const cors = require('cors');
const authRoutes = require('./routes/authRoutes');

const app = express();

// Middleware
app.use(express.json());
app.use(cookieParser());
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:3000',
  credentials: true
}));

// Connect to database
require('./config/db')();

// Routes
app.use('/api/auth', authRoutes);

// Basic route for testing
app.get('/', (req, res) => {
  res.send('Authentication API is running');
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ success: false, message: 'Something went wrong!' });
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));</code></pre>
                
                <h3>Database Connection</h3>
                
                <pre><code>// config/db.js
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB connected successfully');
  } catch (error) {
    console.error('MongoDB connection error:', error.message);
    process.exit(1);
  }
};

module.exports = connectDB;</code></pre>
                
                <h3>User Model with Password Hashing</h3>
                
                <pre><code>// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');

const userSchema = new mongoose.Schema({
  username: {
    type: String,
    required: [true, 'Username is required'],
    unique: true,
    trim: true,
    minlength: [3, 'Username must be at least 3 characters long']
  },
  email: {
    type: String,
    required: [true, 'Email is required'],
    unique: true,
    trim: true,
    lowercase: true,
    match: [/^\S+@\S+\.\S+$/, 'Please enter a valid email address']
  },
  password: {
    type: String,
    required: [true, 'Password is required'],
    minlength: [6, 'Password must be at least 6 characters long']
  },
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Pre-save hook to hash password
userSchema.pre('save', async function(next) {
  // Only hash the password if it's modified (or new)
  if (!this.isModified('password')) return next();
  
  try {
    // Generate a salt
    const salt = await bcrypt.genSalt(10);
    
    // Hash the password along with the new salt
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

const User = mongoose.model('User', userSchema);

module.exports = User;</code></pre>
                
                <h3>Authentication Controller</h3>
                
                <pre><code>// controllers/authController.js
const jwt = require('jsonwebtoken');
const User = require('../models/User');

// Generate JWT token
const generateToken = (userId) => {
  return jwt.sign(
    { id: userId },
    process.env.JWT_SECRET,
    { expiresIn: '1h' }  // Short-lived access token
  );
};

// Generate refresh token
const generateRefreshToken = (userId) => {
  return jwt.sign(
    { id: userId },
    process.env.REFRESH_TOKEN_SECRET,
    { expiresIn: '7d' }  // Longer-lived refresh token
  );
};

// Register new user
exports.register = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    
    // Check if user already exists
    const userExists = await User.findOne({ 
      $or: [{ email }, { username }] 
    });
    
    if (userExists) {
      return res.status(400).json({
        success: false,
        message: 'User with this email or username already exists'
      });
    }
    
    // Create new user
    const user = await User.create({
      username,
      email,
      password // Will be hashed by pre-save hook
    });
    
    // Generate tokens
    const accessToken = generateToken(user._id);
    const refreshToken = generateRefreshToken(user._id);
    
    // Set refresh token in HTTP-only cookie
    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production', // Use secure in production
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
    });
    
    // Return user data and access token
    res.status(201).json({
      success: true,
      user: {
        id: user._id,
        username: user.username,
        email: user.email
      },
      accessToken
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: 'Registration failed',
      error: error.message 
    });
  }
};

// Login user
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find user by email
    const user = await User.findOne({ email });
    
    // Check if user exists and password is correct
    if (!user || !(await user.comparePassword(password))) {
      return res.status(401).json({ 
        success: false, 
        message: 'Invalid email or password' 
      });
    }
    
    // Generate tokens
    const accessToken = generateToken(user._id);
    const refreshToken = generateRefreshToken(user._id);
    
    // Set refresh token in HTTP-only cookie
    res.cookie('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
    });
    
    // Return user data and access token
    res.status(200).json({
      success: true,
      user: {
        id: user._id,
        username: user.username,
        email: user.email
      },
      accessToken
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: 'Login failed',
      error: error.message 
    });
  }
};

// Logout user
exports.logout = (req, res) => {
  // Clear the refresh token cookie
  res.cookie('refreshToken', '', {
    httpOnly: true,
    expires: new Date(0) // Expire immediately
  });
  
  res.status(200).json({ 
    success: true, 
    message: 'Logged out successfully' 
  });
};

// Refresh access token
exports.refreshToken = async (req, res) => {
  try {
    // Get refresh token from cookie
    const refreshToken = req.cookies.refreshToken;
    
    if (!refreshToken) {
      return res.status(401).json({ 
        success: false, 
        message: 'Refresh token not found' 
      });
    }
    
    // Verify refresh token
    const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);
    
    // Find user by ID
    const user = await User.findById(decoded.id);
    
    if (!user) {
      return res.status(401).json({ 
        success: false, 
        message: 'User not found' 
      });
    }
    
    // Generate new access token
    const newAccessToken = generateToken(user._id);
    
    // Return new access token
    res.status(200).json({
      success: true,
      accessToken: newAccessToken
    });
  } catch (error) {
    res.status(401).json({ 
      success: false, 
      message: 'Invalid refresh token',
      error: error.message 
    });
  }
};

// Get current user profile
exports.getCurrentUser = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        message: 'User not found' 
      });
    }
    
    res.status(200).json({
      success: true,
      user
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: 'Error fetching user profile',
      error: error.message 
    });
  }
};</code></pre>
                
                <div class="section-tip">
                    <strong>Security Note:</strong> Never store JWT secrets directly in your code. Use environment variables to store sensitive information like JWT_SECRET and REFRESH_TOKEN_SECRET.
                </div>
            </section>
            
            <section id="step2">
                <h2>Step 2: Creating Middleware for Authentication</h2>
                
                <p>Now, let's create middleware to verify the JWT and protect routes that require authentication:</p>
                
                <pre><code>// middleware/authMiddleware.js
const jwt = require('jsonwebtoken');
const User = require('../models/User');

exports.protect = async (req, res, next) => {
  try {
    let token;
    
    // Check for token in Authorization header
    if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
      // Get token from header (format: "Bearer [token]")
      token = req.headers.authorization.split(' ')[1];
    }
    
    // If no token, deny access
    if (!token) {
      return res.status(401).json({ 
        success: false, 
        message: 'Not authorized, no token provided' 
      });
    }
    
    try {
      // Verify token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Add user to request object
      req.user = await User.findById(decoded.id).select('-password');
      
      next();
    } catch (error) {
      // Token validation failed
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({
          success: false,
          message: 'Token expired'
        });
      }
      
      return res.status(401).json({ 
        success: false, 
        message: 'Not authorized, invalid token' 
      });
    }
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      message: 'Authentication server error',
      error: error.message 
    });
  }
};

// Optional: Role-based authorization middleware
exports.authorize = (...roles) => {
  return (req, res, next) => {
    if (!req.user.role || !roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: `User role ${req.user.role} is not authorized to access this resource`
      });
    }
    next();
  };
};</code></pre>
                
                <h3>Setting Up Authentication Routes</h3>
                
                <pre><code>// routes/authRoutes.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { protect } = require('../middleware/authMiddleware');

// Public routes
router.post('/register', authController.register);
router.post('/login', authController.login);
router.post('/logout', authController.logout);
router.post('/refresh-token', authController.refreshToken);

// Protected routes
router.get('/me', protect, authController.getCurrentUser);

module.exports = router;</code></pre>
                
                <h3>Environment Variables</h3>
                
                <p>Create a .env file in your project root with the following variables:</p>
                
                <pre><code># .env
NODE_ENV=development
PORT=5000
MONGO_URI=mongodb://localhost:27017/auth_tutorial
JWT_SECRET=your_jwt_secret_key_here
REFRESH_TOKEN_SECRET=your_refresh_token_secret_here
CLIENT_URL=http://localhost:3000</code></pre>
                
                <div class="section-tip">
                    <strong>Security Tip:</strong> For production, use strong, randomly generated secrets for your JWT and refresh tokens. You can generate these using the crypto module in Node.js.
                </div>
            </section>
            
            <section id="step3">
                <h2>Step 3: Setting Up the Frontend (React.js)</h2>
                
                <p>Now that our backend is set up, let's create the React components for user authentication.</p>
                
                <h3>Project Structure</h3>
                
                <pre><code>frontend/
├── public/
├── src/
│   ├── components/
│   │   ├── Auth/
│   │   │   ├── Login.js
│   │   │   ├── Register.js
│   │   │   └── ProtectedRoute.js
│   │   ├── Layout/
│   │   │   ├── Navbar.js
│   │   │   └── Footer.js
│   │   └── Dashboard.js
│   ├── context/
│   │   └── AuthContext.js
│   ├── services/
│   │   └── api.js
│   ├── App.js
│   └── index.js
├── .env
└── package.json</code></pre>
                
                <h3>Setting Up API Service</h3>
                
                <pre><code>// src/services/api.js
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

// Create axios instance with custom configs
const api = axios.create({
  baseURL: API_URL,
  withCredentials: true, // Required for cookies to be sent and received
  headers: {
    'Content-Type': 'application/json'
  }
});

// Add a request interceptor to include auth token in headers
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Add a response interceptor to handle token expiration
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    // If error is 401 and not already retrying
    if (error.response.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // Call refresh token endpoint
        const response = await axios.post(
          `${API_URL}/auth/refresh-token`, 
          {}, 
          { withCredentials: true }
        );
        
        // Store new token
        const { accessToken } = response.data;
        localStorage.setItem('accessToken', accessToken);
        
        // Update header and retry
        originalRequest.headers['Authorization'] = `Bearer ${accessToken}`;
        return api(originalRequest);
      } catch (error) {
        // Refresh token failed - logout user
        localStorage.removeItem('accessToken');
        window.location.href = '/login';
        return Promise.reject(error);
      }
    }
    
    return Promise.reject(error);
  }
);

// Auth services
export const authService = {
  register: async (userData) => {
    const response = await api.post('/auth/register', userData);
    if (response.data.accessToken) {
      localStorage.setItem('accessToken', response.data.accessToken);
    }
    return response.data;
  },
  
  login: async (credentials) => {
    const response = await api.post('/auth/login', credentials);
    if (response.data.accessToken) {
      localStorage.setItem('accessToken', response.data.accessToken);
    }
    return response.data;
  },
  
  logout: async () => {
    await api.post('/auth/logout');
    localStorage.removeItem('accessToken');
  },
  
  getCurrentUser: async () => {
    return await api.get('/auth/me');
  }
};

export default api;</code></pre>
                
                <h3>Authentication Context</h3>
                
                <pre><code>// src/context/AuthContext.js
import React, { createContext, useState, useEffect, useContext } from 'react';
import { authService } from '../services/api';

// Create context
const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // Load user on first render
  useEffect(() => {
    const loadUser = async () => {
      try {
        const token = localStorage.getItem('accessToken');
        
        if (!token) {
          setIsLoading(false);
          return;
        }
        
        const response = await authService.getCurrentUser();
        setUser(response.data.user);
        setIsAuthenticated(true);
      } catch (error) {
        localStorage.removeItem('accessToken');
      } finally {
        setIsLoading(false);
      }
    };
    
    loadUser();
  }, []);
  
  // Register user
  const register = async (userData) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const response = await authService.register(userData);
      setUser(response.user);
      setIsAuthenticated(true);
      return response;
    } catch (error) {
      setError(error.response?.data?.message || 'Registration failed');
      throw error;
    } finally {
      setIsLoading(false);
    }
  };
  
  // Login user
  const login = async (credentials) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const response = await authService.login(credentials);
      setUser(response.user);
      setIsAuthenticated(true);
      return response;
    } catch (error) {
      setError(error.response?.data?.message || 'Login failed');
      throw error;
    } finally {
      setIsLoading(false);
    }
  };
  
  // Logout user
  const logout = async () => {
    try {
      await authService.logout();
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      setUser(null);
      setIsAuthenticated(false);
      setError(null);
    }
  };
  
  return (
    <AuthContext.Provider 
      value={{ 
        user, 
        isAuthenticated, 
        isLoading, 
        error, 
        register, 
        login, 
        logout 
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

// Custom hook for using the auth context
export const useAuth = () => {
  const context = useContext(AuthContext);
  
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  
  return context;
};</code></pre>
                
                <div class="section-tip">
                    <strong>UX Tip:</strong> Always give users meaningful feedback during authentication processes. Show loading states, validation errors, and success messages to improve user experience.
                </div>
            </section>
            
            <section id="react-components">
                <h3>Creating React Authentication Components</h3>
                
                <p>Let's create the login and registration components:</p>
                
                <pre><code>// src/components/Auth/Login.js
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';

const Login = () => {
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  });
  const [formError, setFormError] = useState('');
  const { login, error, isLoading } = useAuth();
  const navigate = useNavigate();
  
  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setFormError('');
    
    // Basic validation
    if (!formData.email || !formData.password) {
      setFormError('Please fill in all fields');
      return;
    }
    
    try {
      await login(formData);
      navigate('/dashboard');
    } catch (error) {
      setFormError(error.response?.data?.message || 'Login failed');
    }
  };
  
  return (
    <div className="auth-form-container">
      <h2>Login</h2>
      
      {(formError || error) && (
        <div className="error-message">{formError || error}</div>
      )}
      
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label htmlFor="email">Email</label>
          <input 
            type="email" 
            id="email" 
            name="email" 
            value={formData.email} 
            onChange={handleChange} 
            required 
          />
        </div>
        
        <div className="form-group">
          <label htmlFor="password">Password</label>
          <input 
            type="password" 
            id="password" 
            name="password" 
            value={formData.password} 
            onChange={handleChange} 
            required 
          />
        </div>
        
        <button 
          type="submit" 
          className="auth-button" 
          disabled={isLoading}
        >
          {isLoading ? 'Logging in...' : 'Login'}
        </button>
      </form>
      
      <p className="auth-redirect">
        Don't have an account? <Link to="/register">Register</Link>
      </p>
    </div>
  );
};

export default Login;</code></pre>
                
                <pre><code>// src/components/Auth/Register.js
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';

const Register = () => {
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [formError, setFormError] = useState('');
  const { register, error, isLoading } = useAuth();
  const navigate = useNavigate();
  
  const handleChange = (e) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value
    });
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    setFormError('');
    
    // Validation
    if (!formData.username || !formData.email || !formData.password) {
      setFormError('Please fill in all fields');
      return;
    }
    
    if (formData.password.length < 6) {
      setFormError('Password must be at least 6 characters long');
      return;
    }
    
    if (formData.password !== formData.confirmPassword) {
      setFormError('Passwords do not match');
      return;
    }
    
    try {
      // Remove confirmPassword before sending
      const { confirmPassword, ...userData } = formData;
      await register(userData);
      navigate('/dashboard');
    } catch (error) {
      setFormError(error.response?.data?.message || 'Registration failed');
    }
  };
  
  return (
    <div className="auth-form-container">
      <h2>Register</h2>
      
      {(formError || error) && (
        <div className="error-message">{formError || error}</div>
      )}
      
      <form onSubmit={handleSubmit}>
        <div className="form-group">
          <label htmlFor="username">Username</label>
          <input 
            type="text" 
            id="username" 
            name="username" 
            value={formData.username} 
            onChange={handleChange} 
            required 
          />
        </div>
        
        <div className="form-group">
          <label htmlFor="email">Email</label>
          <input 
            type="email" 
            id="email" 
            name="email" 
            value={formData.email} 
            onChange={handleChange} 
            required 
          />
        </div>
        
        <div className="form-group">
          <label htmlFor="password">Password</label>
          <input 
            type="password" 
            id="password" 
            name="password" 
            value={formData.password} 
            onChange={handleChange} 
            required 
          />
        </div>
        
        <div className="form-group">
          <label htmlFor="confirmPassword">Confirm Password</label>
          <input 
            type="password" 
            id="confirmPassword" 
            name="confirmPassword" 
            value={formData.confirmPassword} 
            onChange={handleChange} 
            required 
          />
        </div>
        
        <button 
          type="submit" 
          className="auth-button" 
          disabled={isLoading}
        >
          {isLoading ? 'Registering...' : 'Register'}
        </button>
      </form>
      
      <p className="auth-redirect">
        Already have an account? <Link to="/login">Login</Link>
      </p>
    </div>
  );
};

export default Register;</code></pre>
                
                <h3>Protected Route Component</h3>
                
                <pre><code>// src/components/Auth/ProtectedRoute.js
import { Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '../../context/AuthContext';

const ProtectedRoute = () => {
  const { isAuthenticated, isLoading } = useAuth();
  
  // Show loading spinner while checking authentication
  if (isLoading) {
    return <div className="loading-spinner">Loading...</div>;
  }
  
  // Redirect to login if not authenticated
  return isAuthenticated ? <Outlet /> : <Navigate to="/login" />;
};

export default ProtectedRoute;</code></pre>
                
                <h3>Main App Component</h3>
                
                <pre><code>// src/App.js
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';

// Components
import Navbar from './components/Layout/Navbar';
import Footer from './components/Layout/Footer';
import Login from './components/Auth/Login';
import Register from './components/Auth/Register';
import Dashboard from './components/Dashboard';
import ProtectedRoute from './components/Auth/ProtectedRoute';

// Styles
import './App.css';

const App = () => {
  return (
    <AuthProvider>
      <Router>
        <div className="app-container">
          <Navbar />
          <main className="main-content">
            <Routes>
              <Route path="/" element={<Navigate to="/login" />} />
              <Route path="/login" element={<Login />} />
              <Route path="/register" element={<Register />} />
              
              {/* Protected routes */}
              <Route element={<ProtectedRoute />}>
                <Route path="/dashboard" element={<Dashboard />} />
                {/* Add more protected routes here */}
              </Route>
              
              {/* Catch all route */}
              <Route path="*" element={<Navigate to="/" />} />
            </Routes>
          </main>
          <Footer />
        </div>
      </Router>
    </AuthProvider>
  );
};

export default App;</code></pre>
            </section>
            
            <section id="step4">
                <h2>Step 4: Managing Tokens and Sessions</h2>
                
                <p>Now let's implement token refresh and session management strategies to enhance the security and user experience.</p>
                
                <h3>The JWT and Cookie Implementation</h3>
                
                <p>Our implementation follows a dual-token approach:</p>
                
                <ol>
                    <li><strong>Access Token</strong>: Short-lived (1 hour) JWT stored in memory (localStorage in our example for simplicity) and used for API requests.</li>
                    <li><strong>Refresh Token</strong>: Long-lived (7 days) JWT stored in an HTTP-only cookie and used to obtain new access tokens when they expire.</li>
                </ol>
                
                <h3>Handling Token Expiration</h3>
                
                <p>When an access token expires, the Axios interceptor we set up will:</p>
                
                <ol>
                    <li>Detect the 401 Unauthorized error</li>
                    <li>Attempt to get a new access token using the refresh token</li>
                    <li>Retry the original request with the new token</li>
                    <li>If refresh fails, log the user out and redirect to login</li>
                </ol>
                
                <h3>Silent Authentication</h3>
                
                <p>When a user reloads the page, we automatically check if they're still authenticated:</p>
                
                <pre><code>// In AuthContext.js - LoadUser effect
useEffect(() => {
  const loadUser = async () => {
    try {
      // Try to get current user with existing token
      const response = await authService.getCurrentUser();
      setUser(response.data.user);
      setIsAuthenticated(true);
    } catch (error) {
      // Silent refresh failed - clear state
      localStorage.removeItem('accessToken');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Only run if we have a token
  const token = localStorage.getItem('accessToken');
  if (token) {
    loadUser();
  } else {
    setIsLoading(false);
  }
}, []);</code></pre>
                
                <h3>Proper Logout Process</h3>
                
                <p>A complete logout should:</p>
                
                <ol>
                    <li>Remove the access token from localStorage</li>
                    <li>Clear the refresh token cookie by calling the server logout endpoint</li>
                    <li>Reset the authentication state in the frontend</li>
                    <li>Redirect the user to the login page</li>
                </ol>
                
                <pre><code>// In AuthContext.js - logout function
const logout = async () => {
  try {
    // Call server to invalidate refresh token cookie
    await authService.logout();
  } catch (error) {
    console.error('Logout error:', error);
  } finally {
    // Clear local state regardless of server response
    localStorage.removeItem('accessToken');
    setUser(null);
    setIsAuthenticated(false);
    // Usually handled by the component that calls logout
    // navigate('/login');
  }
};</code></pre>
                
                <div class="section-tip">
                    <strong>Security Tip:</strong> Consider implementing token revocation on the server side by maintaining a blacklist of invalidated refresh tokens or using a Redis store to track valid sessions.
                </div>
            </section>
            
            <section id="step5">
                <h2>Step 5: Security Best Practices</h2>
                
                <p>Security should be a top priority when implementing authentication. Here are some essential best practices to follow:</p>
                
                <h3>Secure Cookie Settings</h3>
                
                <pre><code>// When setting cookies, use these options
res.cookie('refreshToken', refreshToken, {
  httpOnly: true,  // Prevents JavaScript access
  secure: process.env.NODE_ENV === 'production',  // HTTPS only in production
  sameSite: 'strict',  // Prevents CSRF
  maxAge: 7 * 24 * 60 * 60 * 1000  // 7 days in milliseconds
});</code></pre>
                
                <h3>CSRF Protection</h3>
                
                <p>For additional protection against Cross-Site Request Forgery:</p>
                
                <ol>
                    <li>Install the csurf package: <code>npm install csurf</code></li>
                    <li>Implement CSRF protection on your server:</li>
                </ol>
                
                <pre><code>// In server.js
const csrf = require('csurf');
const csrfProtection = csrf({ 
  cookie: { 
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production'
  } 
});

// Apply to routes that need protection
app.use('/api/auth', csrfProtection, authRoutes);

// Provide CSRF token to client
app.get('/api/csrf-token', csrfProtection, (req, res) => {
  res.json({ csrfToken: req.csrfToken() });
});</code></pre>
                
                <p>Then in your frontend, include the token in requests:</p>
                
                <pre><code>// Get the CSRF token when app initializes
const getCsrfToken = async () => {
  const response = await axios.get('/api/csrf-token');
  axios.defaults.headers['X-CSRF-Token'] = response.data.csrfToken;
};</code></pre>
                
                <h3>HTTPS Enforcing</h3>
                
                <p>Always use HTTPS in production environments:</p>
                
                <pre><code>// In server.js (for Express)
if (process.env.NODE_ENV === 'production') {
  app.use((req, res, next) => {
    if (req.header('x-forwarded-proto') !== 'https') {
      res.redirect(`https://${req.header('host')}${req.url}`);
    } else {
      next();
    }
  });
}</code></pre>
                
                <h3>Password Requirements</h3>
                
                <p>Implement stronger password requirements in your validation:</p>
                
                <pre><code>// Server-side validation in controllers/authController.js
const validatePassword = (password) => {
  const minLength = 8;
  const hasUpperCase = /[A-Z]/.test(password);
  const hasLowerCase = /[a-z]/.test(password);
  const hasNumbers = /\d/.test(password);
  const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(password);
  
  const errors = [];
  
  if (password.length < minLength) {
    errors.push(`Password must be at least ${minLength} characters long`);
  }
  
  if (!hasUpperCase) {
    errors.push('Password must contain at least one uppercase letter');
  }
  
  if (!hasLowerCase) {
    errors.push('Password must contain at least one lowercase letter');
  }
  
  if (!hasNumbers) {
    errors.push('Password must contain at least one number');
  }
  
  if (!hasSpecialChar) {
    errors.push('Password must contain at least one special character');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};</code></pre>
                
                <h3>Rate Limiting</h3>
                
                <p>Implement rate limiting to prevent brute force attacks:</p>
                
                <pre><code>// In server.js
const rateLimit = require('express-rate-limit');

// Apply rate limiting to auth routes
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // Limit each IP to 10 requests per windowMs
  message: 'Too many login attempts, please try again after 15 minutes'
});

app.use('/api/auth/login', authLimiter);
app.use('/api/auth/register', authLimiter);</code></pre>
                
                <div class="section-tip">
                    <strong>Defense in Depth:</strong> Don't rely on a single security measure. Implement multiple layers of protection to create a robust security posture for your application.
                </div>
            </section>
            
            <section id="step6">
                <h2>Step 6: Troubleshooting and Debugging</h2>
                
                <p>Even with careful implementation, you may encounter issues with your authentication system. Here are some common problems and their solutions:</p>
                
                <h3>CORS Issues</h3>
                
                <p>If you're experiencing CORS errors:</p>
                
                <pre><code>// In server.js
const cors = require('cors');

// Configure CORS with specific options
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:3000',
  credentials: true, // IMPORTANT: needed for cookies to work
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));</code></pre>
                
                <p>On the client side, ensure you're using the <code>withCredentials</code> option:</p>
                
                <pre><code>// In your axios config
axios.defaults.withCredentials = true;</code></pre>
                
                <h3>Cookie Not Being Set</h3>
                
                <p>If cookies aren't being set properly:</p>
                
                <ol>
                    <li>Ensure your server and client are on the same domain or properly configured for cross-origin cookies.</li>
                    <li>Check that the <code>sameSite</code> attribute is compatible with your use case (Strict, Lax, or None with Secure).</li>
                    <li>Verify that <code>credentials: true</code> is set in your CORS configuration.</li>
                    <li>For local development on Chrome, you may need to enable "Allow cookies for local files" in settings.</li>
                </ol>
                
                <h3>Token Expired Error Loop</h3>
                
                <p>If you're experiencing a loop of token expiration errors:</p>
                
                <pre><code>// In your API interceptor, add flag to prevent looping
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    if (error.response.status === 401 && 
        !originalRequest._retry && 
        !originalRequest.url.includes('/refresh-token')) {
      originalRequest._retry = true;
      
      try {
        // Rest of refresh logic...
      } catch (error) {
        // Handle refresh failure
      }
    }
    
    return Promise.reject(error);
  }
);</code></pre>
                
                <h3>Debugging JWT Issues</h3>
                
                <p>To debug JWT token problems:</p>
                
                <ol>
                    <li>Use <a href="https://jwt.io" target="_blank">jwt.io</a> to decode and inspect token contents (never paste production tokens).</li>
                    <li>Check token expiration times and ensure your server's clock is synchronized.</li>
                    <li>Verify that the signature algorithm matches between token creation and verification.</li>
                    <li>Add detailed logging for token validation failures.</li>
                </ol>
                
                <pre><code>// Enhanced JWT verification with better error logging
try {
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  // Token is valid
} catch (error) {
  if (error.name === 'TokenExpiredError') {
    console.log('Token expired at:', error.expiredAt);
  } else if (error.name === 'JsonWebTokenError') {
    console.log('JWT Error:', error.message);
  } else {
    console.log('Other verification error:', error);
  }
}</code></pre>
                
                <div class="section-tip">
                    <strong>Troubleshooting Tip:</strong> Implement detailed logging in your authentication flow that captures the specific points of failure without logging sensitive information like tokens or passwords.
                </div>
            </section>
            
            <section id="conclusion">
                <h2>Conclusion</h2>
                
                <p>In this guide, we've built a comprehensive authentication system using Node.js, Express, React, JWT tokens, and HTTP-only cookies. This approach offers several key advantages:</p>
                
                <ul>
                    <li><strong>Security</strong>: Using HTTP-only cookies for refresh tokens protects against XSS attacks, while keeping access tokens in memory minimizes exposure.</li>
                    <li><strong>User Experience</strong>: The token refresh mechanism provides seamless authentication without requiring users to log in frequently.</li>
                    <li><strong>Scalability</strong>: JWT-based authentication is stateless, making it ideal for distributed systems and microservices.</li>
                    <li><strong>Modern Architecture</strong>: The separation of concerns between backend and frontend follows contemporary best practices.</li>
                </ul>
                
                <p>Remember these key takeaways for implementing authentication:</p>
                
                <ol>
                    <li>Never store sensitive information in JWTs or localStorage.</li>
                    <li>Implement proper CSRF protection alongside your JWT authentication.</li>
                    <li>Always use HTTPS in production environments.</li>
                    <li>Consider the tradeoffs between security and user experience when setting token expiration times.</li>
                    <li>Implement proper error handling and user feedback throughout the authentication flow.</li>
                </ol>
                
                <p>By following these practices, you can create a secure, user-friendly authentication system that protects your users' data while providing a smooth experience.</p>
                
                <p>For further reading, consider exploring:</p>
                
                <ul>
                    <li>OAuth 2.0 and OpenID Connect for third-party authentication</li>
                    <li>Passwordless authentication using email magic links or WebAuthn</li>
                    <li>Multi-factor authentication implementation</li>
                    <li>Role-based access control (RBAC) for more complex authorization needs</li>
                </ul>
            </section>
        </article>
        
        <footer class="footer">
            <p>© 2023 • All rights reserved</p>
            <p>If you found this guide helpful, consider sharing it with your network!</p>
        </footer>
    </div>
</body>
</html>
